
/////////// docker and dockerfile ///////// 

LANCEMENT DOCKER : 
    -d : mode detachable (background)
    -- name : definir le nom du DOCKER

Image : 
<url_register>/<nom de l'image>:<tag>

-----------------------

docker run -d --name c1 nginx:latest : lancement de nginx
docker ps : list docker 
docker stop <id>/<name> : stop 
docker rm -f <id>/<name> : suprimer le docker (-f pour forcer la suppression d'un docker actif)

-----------------------

DOCKER RUN : 
    . -ti : lancer un terminal sur le process
    . -p  : exposition de port 
    . --rm : suppression du conteneur sur sortie
    . --hostname : specifie le nouveau nom de l'hostname 
    . -- dns : specifie le dns de la machine

docker run -ti --name c1 nginx:latest : terminal accessible mais bloqué
docker run -ti --name c1 debian : terminal accessible non bloqué
docker run -ti --name -rm c1 debian : terminal accessible non bloqué et suppression à la fin de l'utilisation 

-----------------------

SUPRIMER DOCKERS :
docker rm -f $(docker ps -qa) : suppression de tout les dockers

-----------------------

#### LES VOLUMES ####

-----------------------

intéret : 
    - Facile pour persister de la donnée.
    - Pratique pour faire des backups
    - Partager entre de multiple conteneur
    - Multiconteneur & permissions
    - locals ou distants

commmande de base : 
docker volume 
        - ls             : lister les volumes 
        - create <name>  : creation d'un nouveau volume
        - rm <name>      : suppression du volume
        - inspect <name> : inspection du volume

paramètre docker run : -v vol:/var/data/

-----------------------

1 : docker run -d --name c1 -v vol:/usr/share/nginx/html/ -p 80:80 nginx:latest : lancement et montage du volume 

docker exec -ti c1 bash : pour se connecter dans un conteneur avec bash (ou pour lance un autre executable)

Creer un docker qui se detruit la fin de son utilisation:
2 : docker run -ti --name c2 --rm -v vol:/usr/share/nginx/html/ debian:latest


-----------------------

### Les differents type de volumes ### 

1. Bind Mount 
2. Volumes Docker 
3. TMPFS

Distinction CLI
. -v ou --volume 
    si nom de volume = volume
    si path = bind 

. --mount + type
    type = bind / volume / tmpfs 


1. Bind Mount
sudo mkdir /data
docker run -d --name c1 --mount type=bind,source=/data/,target=/usr/share/nginx/html -p 80:80 nginx:latest
Option : ,readonly / ,readwrite
docker exec -ti c1 bash

2. Volumes Docker
docker volume create mynginx
docker run -d --name c2 --mount type=volume,src=mynginx,destination=/usr/share/nginx/html -p 81:80 nginx:latest 

3. Tmpfs
docker run -d --name c3 --mount type=tmpfs,destination=/usr/share/nginx/html -p 82:80 nginx:latest 

-----------------------

### USERID pour les volumes ### 

Creation user 
- useradd -u 1111 theo1
- useradd -u 1112 theo2

Creer un repertoire "test" dans le quel on va mettre un Dockerfile

---
FROM debian:latest
RUN useradd -u 1111 theo1
RUN useradd -u 1113 theo3
---
docker build -t myimage:v1.0 .

docker images : pour lister les images en local.


sudo mkdir /myvolume

docker run -d --name c1 -v /myvolume/:/data/ myimage:v1.0
(pas dans cette image de process infinie)

docker rm -f c1

docker run -d --name c1 -v /myvolume/:/data/ myimage:v1.0 sleep infinity
(pour avoir cette fois si le docker avec un process en arriere plan)

docker exec -ti c1 bash
touch /data/titi

maintenant aller voir dans l'host le volume /myvolume 
ls -la /myvolume 

total 8
drwxr-xr-x  2 root root 4096 Mar 14 15:53 .
drwxr-xr-x 21 root root 4096 Mar 14 15:47 ..
-rw-r--r--  1 root root    0 Mar 14 15:53 titi

docker rm -f c1


docker run -d --name c1 -v /myvolume/:/data/ -u theo1 myimage:v1.0 sleep infinity

touch /data/toto -> touch: cannot touch '/data/toto': Permission denied



-----------------------
### Container Runtimes hauts & bas niveaux ###

"OCI" --- "Container Runtime" --- "Linux"

OCI = Open Container Initiative
Standars qui a pour vocation de definir des normes d'images Container
Layers + manifest + config 



-----------------------

### Variable d'environnement (env,enfile...) ###

sudo docker run -tid --name testenv --env MYVAR="123" debian:latest

docker exec -ti testenv bash
Aller regarder dans le container les variables d'environnement avec la cmd "env".

---
root@cb9e44034297:/# env
HOSTNAME=cb9e44034297
MYVAR=123
PWD=/
HOME=/root
TERM=xterm
SHLVL=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
_=/usr/bin/env
---

Cette methode fonctionne mais n'est pas securisée par exemple pour les passwords.

Pour se fair, on vas creer un fichier "var_mdp.lst"
dans le quel nous mettron nos variables d'ENV.

---
MYPASSWORD="safepassword"
MYUSER="secretuser"
MYDB="BDDofficial"
---

sudo docker run -tid --name testenv --env-file var_mdp.lst debian:latest
docker exec -ti testenv bash
Aller regarder dans le container les variables d'environnement avec la cmd "env".

---
HOSTNAME=553c2ac8a657
PWD=/
HOME=/root
MYPASSWORD="safepassword"
TERM=xterm
SHLVL=1
MYUSER="secretuser"
MYDB="BDDofficial"
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
_=/usr/bin/env
---

-----------------------

### DOCKERFILE créer une image ###

dockerfile est une fichier de configuration dans le but de créer une image 

List d'instruction principal
    - RUN : lancement de commmande (apt ...)
    - ENV : variable d'environnement
    - EXPOSE : exposition de ports
    - VOLUMES : définit les volumes 
    - COPY : copy entre host et conteneur
    - ENTRYPOINT : processus maitre

Intérêts de dockerfile
    - relancer une création d'inage à tout moment
    - meilleure visibilité sur la configuration
    - script edition de docker file 
    - création d'image de prod ou dev



Dans le Dockerfile : 
---
FROM debian:latest
RUN apt-get update \ 
&& apt-get install -y vim git \
&& apt-get clean \
---

Pour constuire l'image :
. docker build -t imagetest:v1.0 .

Pour verifier l'existance de l'image :
. docker image ls

Pour verifier les sequences appliqué a la création d'image : 
. docker history imagetest:v1.0

Pour lancer l'image : 
. docker run -tid --name test imagetest:v1.0 

Verifier que vim et git sont bien installé.

(en ligne de commande dans la host, 
on peux supprimer le conteneur avec "docker rm -f <name>"
on peux supprimer l'image créer avec "docker rmi <name img>"
. docker images
. docker ps )

-----------------------

### Les microservices ###

. Franctionner pour mieux maitriser l'environnement
    - Réseau
    - version de services

. Franctionner pour adapter la ressources
    - Plus de workers : produire plus 
    - Plus de serveurs web : recevoir plus de trafic de manière indepedante

. Augmenter la vitesse de deploiement
. Réduire les single point of failure (SPOF)


-- Exemple minimaliste ---

. 1 page index.html à mettre à jour
. 1 variables calculées (bash)

. 2 conteneurs
    - 1 serveur web nginx 
    - 1 conteneur php (worker)

- - - - - - - - - - - - - -
Dockerfile nginx
---
FROM debian:latest
RUN apt-get update
RUN apt-get install -y nginx 
VOLUME /var/www/html
ENTRYPOINT ["nginx", "-g", "daemon off;"]
---
Dockerfile worker
---
FROM php:7.2-cli
COPY rollon.sh /
COPY affichage.php /
RUN chmod 755 /rollon.sh
ENTRYPOINT ["./rollon.sh"]
---
rollon.sh
---
#! /bin/bash
x=0
while true
do
echo $x > /var/www/html/worker1.txt
((x=x+1))
php /affichage.php
sleep 2
done
---
affichage.php
---
<?php
$file1='/var/www/html/worker1.txt';
$Data1="";

# worker data
if (file_exists($file1)) {
$fh = fopen($file1,'r');
while ($line = fgets($fh)) {
  $worker1 = $line;
}
fclose($fh);
}
# affichage
$File = "/var/www/html/index.html";
$Handle = fopen($File, 'w');
$Data1 = "worker 1 vaut ".$worker1."\n";
fwrite($Handle, $Data1);

fclose($Handle);
?>
---


-----------------------

### Inspection des Container ###

docker inspect [OPTIONS] NAME|ID [NAME|ID...]

Par default "docker inspect <name>" renvoi le resultat de l'inspection detaillé sous fornat json.

On vas pourvoir apr exemple recupérer
- docker status 
- la taille du docker 
- config Réseaux 
- etc ...

Par la suite on poura utiliser des commande plus specifique comme : 
. docker inspect --format='{{.Config.Image}}' <Name | ID>


La commande suivant permet par exemple d'énumérer les different container grace à leur ID, suivi de leur address IP.
. for id in $(docker ps -aq); do docker inspect -f "{{.Name}} - - {{.NetworkSettings.IPAddress}}" $id;done 
----------------------- 
RESEAU 
### Expose vs Publish ###

Expose = exposer un port
Publish = ports de publication

Expose permet d'exposer le port du conteneur.
Publish permet de faire une redirection de port du conteneur a la machine hote.


test 1: 

. docker run --name c1 -d debian sleep infinity

Dans le container : 
. apt install iputils-ping net-tools
. ifconfig
ping l'ip de host à l'interieur du bridge : 
. ping 127.0.0.1
ping dns google : 
. ping 8.8.8.8

pour mieux comprendre le chemin de la requete nous pouvons utiliser :
. traceroute 8.8.8.8


. attention un conteneur n'a pas d'ip fixe (stop/start)
. utiliser les DNS ou api/socket docker 

test 2: 
start c1
docker run -d --name c1 nginx:latest 

docker inspect c1 --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'
-> 172.17.0.2

stop c1
docker stop c1

start c2
docker run -d --name c2 nginx:latest 

start c1
docker start c1

docker inspect c1 --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'
-> 172.17.0.3

On voie donc dans cette exemple que les ip(s) fournie par docker ne sont pas fixe.


### Docker Network ###

. docker network [connect/create/disconnect/inspect/ls/prune/rm]

- Communication entre conteneurs ou à l'exterieur
- Differents types : bridge, host, none, overlay
- Attention un conteneur n'a pas d'ip fixe (stop / start)


test : 
docker network create --driver=bridge --subnet=192.166.0.0/24 netnet2
docker run -d --name c1 --network netnet2 nginx:latest
docker run -d --name c1 --network netnet2 nginx:latest

docker exec -ti c1 bash
-> apt update
-> apt install iputils-ping
-> ping c2
---
64 bytes from c2.netnet2 (192.166.0.4): icmp_seq=1 ttl=64 time=0.419 ms
64 bytes from c2.netnet2 (192.166.0.4): icmp_seq=2 ttl=64 time=0.309 ms
64 bytes from c2.netnet2 (192.166.0.4): icmp_seq=3 ttl=64 time=0.341 ms
---

On peut voir que l'on peux maintenant communiquer avec le name de la vm qui fait une redirection vers l'ip.

On peut aussi aller regarder dans 
.docker inspect netnet2
pour voir la configuration du reseau netnet2


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




////// DOCKER COMPOSE /////

Docker compose c'est quoi ? Pour l'utiliser ? Intérêts ?

. Lancer des conteneur à cordonner 
. Meilleur gestion des dépendance (réseau, volumes ....)
. Utile pour les services qui comprend, un ou plusieur services.
. Facile à partager et à versionner.

----- 

Les principals commande pour la création des services :

Pour construire l'image 
    . docker-compose build 
Pour construire et run 
    . docker-compose up
Pour le mode détaché
    . docker-compose up -d

Les principals commande pour la gestion des services :

Pour lister l'état des services :
    . docker-compose ps -a 
Pour demarer et stoper des services : 
    . docker-compose start/stop
Pour supprimer des services : 
    . docker-compose rm 

Pour stoper et supprimer
    . docker-compose down 


service apache2 restart

-default-authentication-plugin=mysql_native_password
SELECT User, Host, Password FROM mysql.user;


RENAME USER "root"@"localhost" TO "root"@"0.0.0.0";

GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password';
flush privileges;

SHOW GRANTS;